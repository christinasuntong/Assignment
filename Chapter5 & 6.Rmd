---
title: "Chapter 5 & 6"
author: "Tong Sun"
date: "2/2/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## 5.8
We will now perform cross-validation on a simulated data set.
###(a)
Generate a simulated data set as follows. In this data set, what is n and what is p? Write out the model used to generate the data in equation form.
```{r}
set.seed(1)
y <- rnorm(100)
x <- rnorm(100)
y <- x - 2 * x^2 + rnorm(100)
```
Here we have that n = 100 and p = 2, the model used is $Y = X - 2X^2 + \epsilon$.

###(b)
Create a scatterplot of X against Y. Comment on what you find.
```{r}
plot(x, y)
```
I find that the data obviously holds a curved relationship.

###(c)
Set a random seed, and then compute the LOOCV errors that result from fitting the following four models using least squares:
i. $Y=\beta_0+\beta_1X+\epsilon$
```{r}
library(boot)
set.seed(1)
model1 <- data.frame(x, y)
glm.1 <- glm(y ~ x)
cv.glm(model1 ,glm.1) $ delta[1]
```


ii. $Y=\beta_0+\beta_1X+\beta_2X^2+\epsilon$
```{r}
# 'poly' function returns or evaluates orthogonal polynomials of degree 1 to degree over the specified set of points 'x'
glm.2 <- glm(y ~ poly(x, 2))
cv.glm(model1, glm.2)$delta[1]
```

iii. $Y=\beta_0+\beta_1X+\beta_2X^2+\beta_3X^3+\epsilon$
```{r}
glm.3 <- glm(y ~ poly(x, 3))
cv.glm(model1, glm.3)$delta[1]
```

iv. $Y=\beta_0+\beta_1X+\beta_2X^2+\beta_3X^3+\beta_4X^4+\epsilon$
```{r}
glm.4 <- glm(y ~ poly(x, 4))
cv.glm(model1, glm.4)$delta[1]
```

Note you may find it helpful to use the data.frame() function to create a single data set containing both X and Y.

###(d)
Repeat (c) using another random seed, and report your results. Are your results the same as what you got in (c)? Why?
```{r}
set.seed(100)
glm.1 <- glm(y ~ x)
cv.glm(model1 ,glm.1) $ delta[1]
```

```{r}
glm.2 <- glm(y ~ poly(x, 2))
cv.glm(model1, glm.2)$delta[1]
```

```{r}
glm.3 <- glm(y ~ poly(x, 3))
cv.glm(model1, glm.3)$delta[1]
```

```{r}
glm.4 <- glm(y ~ poly(x, 4))
cv.glm(model1, glm.4)$delta[1]
```

I find that both of these two seeds above have the same results because LOOCV evaluates n folds of a single observation.
###(e)
Which of the models in (c) had the smallest LOOCV error? Is this what you expected? Explain your answer.

I find that the LOOCV estimates from (c) for the lowest test MSE is "glm.2", which has quadratic predictor in the equation. I also see that in (b) that the relationship between "x" and "y" is quadratic. So I think this result of model fitting is considerable.

###(f)
Comment on the statistical significance of the coefficient estimates that results from fitting each of the models in (c) using least squares. Do these results agree with the conclusions drawn based on the cross-validation results?

```{r}
summary(glm.4)
```

The p-values show that the linear and quadratic terms are statistically significant , which have the p-values lower than 0.05, and that the cubic and 4th degree terms are not statistically significant. Therefore, this result agrees with the conclusions drawn based on the cross-validation results.

## 6.2
For parts (a) through (c), indicate which of i through iv is correct. Justify your answer.
###(a)
The lasso, relative to least squares, is:
i. More flexible and hence will give improved prediction accuracy when its increase in bias is less than its decrease in variance.
ii. More flexible and hence will give improved prediction accuracy when its increase in variance is less than its decrease in bias.
iii. Less flexible and hence will give improved prediction accuracy when its increase in bias is less than its decrease in
variance.
iv. Less flexible and hence will give improved prediction accuracy when its increase in variance is less than its decrease
in bias.

The third one is right. The lasso, relative to least squares, is less flexible and hence will give improved prediction accuracy when its increase in bias is less than its decrease in variance.

###(b)
Repeat (a) for ridge regression relative to least squares.

Also the third one is right. The ridge regression relative to least squares, is less flexible and hence will give improved prediction accuracy when its increase in bias is less than its decrease in variance.

###(c)
Repeat (a) for non-linear methods relative to least squares.

The second one is right. The non-linear methods relative to least squares, is more flexible and hence will give improved prediction accuracy when its increase in variance is less than its decrease in bias.

## 6.9
In this exercise, we will predict the number of applications received using the other variables in the College data set.
###(a)
Split the data set into a training set and a test set.
```{r}
library(ISLR)
data(College)
set.seed(11)
data1 <- sample(1:dim(College)[1], dim(College)[1] / 2)
data2 <- -data1
train <- College[data1, ]
test <- College[data2, ]
```
Here I got a training set named "train" and a test set named "test".

###(b)
Fit a linear model using least squares on the training set, and report the test error obtained.
```{r}
fit1 <- lm(Apps ~ ., data = train)
pred1 <- predict(fit1, test)
mean((pred1 - test$Apps)^2)
```
Using least squares on the training set, the test error obtained is 1026096.

###(c)
Fit a ridge regression model on the training set, with $\lambda$ chosen by cross-validation. Report the test error obtained.
```{r}
library(glmnet)
train.mat <- model.matrix(Apps ~., data = train)
test.mat <- model.matrix(Apps ~., data = test)
grid <- 10 ^ seq (4, -2, length = 100)
ridge.mod <- glmnet(train.mat, train$Apps, alpha = 0,lambda = grid, thresh = 1e-12)
cv.out <- cv.glmnet(train.mat, train$Apps, alpha = 0,lambda = grid, thresh = 1e-12)
bestlam <- cv.out$lambda.min
bestlam
```
```{r}
ridge.pred <- predict(ridge.mod, s = bestlam, newx = test.mat)
mean((ridge.pred - test$Apps) ^2)
```
It would be better to use cross-validation to choose the tuning parameter $\lambda$. Here I set a random seed first so the results will be reproducible, since the choice of the cross-validation folds is random. Therefore, I see that the value of $\lambda$ that results in the smallest cross-validation error is 393.8031. And the test MSE is 1273242, which represents a further improvement over the test MSE that I got using least squares.

###(d)
Fit a lasso model on the training set, with $\lambda$ chosen by cross-validation. Report the test error obtained, along with the number of non-zero coefficient estimates.
```{r}
lasso.mod <- glmnet(train.mat, train$Apps, alpha = 1, lambda = grid)
plot(lasso.mod)
set.seed(1)
cv.out <- cv.glmnet(train.mat, train$Apps, alpha = 1)
plot(cv.out)
bestlam.lasso <- cv.out$lambda.min
bestlam.lasso
lasso.pred <- predict(lasso.mod, s = bestlam.lasso, newx = test.mat)
mean((lasso.pred - test$Apps) ^2)
```
We can see from the coefficient plot that depending on the choice of tuning parameter, some of the coefficients will be exactly equal to zero. Next I perform cross-validation and compute the associated test error.

```{r}
predict(lasso.mod, s = bestlam.lasso, type = "coefficients")
```


###(e)
Fit a PCR model on the training set, with M chosen by cross-validation. Report the test error obtained, along with the value
of M selected by cross-validation.

###(f)
Fit a PLS model on the training set, with M chosen by cross-validation. Report the test error obtained, along with the value
of M selected by cross-validation.

###(g)
Comment on the results obtained. How accurately can we predict the number of college applications received? Is there much difference among the test errors resulting from these five approaches?

## 6.10
We have seen that as the number of features used in a model increases, the training error will necessarily decrease, but the test error may not. We will now explore this in a simulated data set.
###(a)
Generate a data set with p = 20 features, n = 1,000 observations, and an associated quantitative response vector generated according to the model $Y=X\beta +\epsilon$, where $\beta$ has some elements that are exactly equal to zero.
```{r}
set.seed(1)
x <- matrix(rnorm(1000 * 20), 1000, 20)
beta <- rnorm(20)
beta[1] <- 0
beta[5] <- 0
beta[10] <- 0
beta[15] <- 0
beta[20] <- 0
epsil <- rnorm(1000)
y <- x %*% beta + epsil
```

###(b)
Split your data set into a training set containing 100 observations and a test set containing 900 observations.
```{r}
part1 <- sample(seq(1000), 100, replace = FALSE)
part2 <- -part1
x.train <- x[part1, ]
x.test <- x[part2, ]
y.train <- y[part1]
y.test <- y[part2]
```

###(c)
Perform best subset selection on the training set, and plot the training set MSE associated with the best model of each size.
```{r}
data1 <- data.frame(y = y.train, x = x.train)
library(leaps)
regfit.full <- regsubsets(y ~ ., data = data1, nvmax = 20)
train.mat <- model.matrix(y ~ ., data = data1, nvmax = 20)
error <- rep(NA, 20)
for(i in 1 :20){
  coef <- coef(regfit.full, id = i)
  pred <- train.mat[, names(coef)] %*% coef
  error[i] <- mean((pred - y.train) ^ 2)
}
plot(error, xlab = "Number of Predictors", ylab = "Training MSE", pch = 19, type = "b")
```


###(d)
Plot the test set MSE associated with the best model of each size.
```{r}
data2 <- data.frame(y = y.test, x = x.test)
test.mat <- model.matrix(y ~ ., data = data2, nvmax = 20)
error <- rep(NA, 20)
for(i in 1 :20){
  coef <- coef(regfit.full, id = i)
  pred <- test.mat[, names(coef)] %*% coef
  error[i] <- mean((pred - y.test) ^ 2)
}
plot(error, xlab = "Number of Predictors", ylab = "Test MSE", pch = 19, type = "b")
```


###(e)
For which model size does the test set MSE take on its minimum value? Comment on your results. If it takes on its minimum value for a model containing only an intercept or a model containing all of the features, then play around with the way that you are generating the data in (a) until you come up with a scenario in which the test set MSE is minimized for an intermediate model size.
```{r}
which.min(error)
```
The 15-variables model has the smallest test MSE.

###(f)
How does the model at which the test set MSE is minimized compare to the true model used to generate the data? Comment on the coefficient values.
```{r}
coef(regfit.full, which.min(error))
```


###(g)




## 6.11